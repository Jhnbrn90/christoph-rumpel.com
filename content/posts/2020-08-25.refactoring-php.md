---
title: Refactoring PHP
categories: PHP
summary: I've been programming PHP now for almost 10 years and if there is one thing I learned over this period, it's that readability is the key for maintainable and sustainable code. This is why I see refactoring as one of my main skills today. In this post, I share with you my refactoring practices for PHP.
preview_image:
preview_image_twitter:
hidden: true
---

## Early Returns

The following code example has two nested if/else statements which leads to code that is difficult to grasp. First it leads to `indention` which tells our brain that we have multiple statements that are connected. Additionally, we have an `else` statements which makes the structure even more complicate since we always have to keep in mind the `if` when looking at the `else`.

### Before

```php
public function calculateScore(User $user): int
{
    if ($user->inactive) {
        $score = 0;
    } else {
        if ($user->hasBonus) {
            $score = $user->score + $this->bonus;
        } else {
            $score = $user->score;
        }
    }

    return $score;
}
```

The concept of "early returns" refers to a practice where we try to void nesting by breaking a structure down to specific actions. In return we will get a more linear code which is much easier to grasp. Every case is separated and good to read by itself. Don't be afraid of using multiple `return` statements.


### After
```php
public function calculateScore(User $user): int
{
    if ($user->inactive) {
        return 0;
    }

    if ($user->hasBonus) {
        return $user->score + $this->bonus;
    }

    return $user->score;
}
```

But this is also true for a simple if/else statement.

### Before

```php
public function sendInvoice(Invoice $invoice): void
{
    if($user->notificationChannel === 'Slack')
    {
        $this->notifier->slack($invoice);
    } else {
        $this->notifier->email($invoice);
    }
}
```

The given code example is not complicated at all, still it can be approved by returning early. It's these little things that make a big impact over time.

### After
```php
public function sendInvoice(Invoice $invoice): bool
{
    if($user->notificationChannel === 'Slack')
    {
        return $this->slackNotifier->send($invoice);
    }

    return $this->notifier->send($invoice);
}
```

By following this practice you will see that more complicated conditions will come first and the simple returns will be placed at the end.

## Explicit Code

### Before
```php
$status = $user->status('pending');
```

### After
```php
$isUserPending = $user->isStatus('pending');
```

### Before
```php
return $this->factoryCollection->factoryReloadedExists();
```

Don't be afraid of using long variable or method names. It is more important to make clear what you are doing. The following method checks if there is one or more related factories given. The previous name made it hard to tell if we check for one or multiple items.

### After
```php
return $this->factoryCollection->atLeastOneFactoryReloadedExists();
```

## Extract To Methods


The following example is from a project where I imported users from an external API via a console command. Here is what it does:

* Collects the API from user input
* Call the API to get the users
* Create a progress bar to give the user some info about the progress
* Store users to the database
* Show success message
* Backup the import data for later

It is not that much what is happening here, still it already looks messy and is hard to read.

### Before
```php
public function handle()
{
    $url = $this->option('url') ?: $this->ask('Please provide the import URL');

    $response = Http::get($url);

    $usersToImport = $response->json()['results'];

    $bar = $this->output->createProgressBar(count($usersToImport));
    $bar->start();

    collect($usersToImport)->each(function (array $userAttributes) use ($bar) {
        User::create($userAttributes);
        $bar->advance(1);
    });

    $bar->finish();

    $this->info('Thanks. Users have been imported.');

    if($this->option('with-backup')){
        Storage::disk('backups')
            ->put(date('Y-m-d').'-import.json', $response->body());
    }
}
```

By extracting the different tasks into methods, you get a nice overview of what is happening. If you're interested in more details, you can check the methods. 

### After
```php
public function handle()
{
    $url = $this->option('url') ?: $this->ask('Please provide the import URL');

    $response = Http::get($url);

    $this->storeUsers($response);

    $this->info('Thanks. Users have been imported.');

    $this->storeImportBackupIfAsked($response);
}
```

Another example here is about querying data from your database.

### Before
```php
User::whereNotNull('subscribed')->where('status', 'active');
```

What we are interested here are `subscribers`, not which database fields are needed to define a subscribed user.
In Laravel, you can use `scopes` to hide query details which are not useful. Another advantage is that you can reuse scopes.

### After
```php
User::subscribed();
```

This becomes even more useful when your query gets longer and complicated like in the next example from Spatie's Mailcoach.

### Before
```php
Campaign::whereHas(
            'emailList',
            fn (Builder $query) => $query->where('report_campaign_summary', true)
        )
        ->whereNull('summary_mail_sent_at');
```

It takes a few seconds until you understand what this query is doing. Every second counts when you try to get yourself familiar with a new code base or when you came back to project after some time. That's why scope methods help a lot to improve readability and reuseability of your application. 

### After
```php
Campaign::needsSummaryToBeReported();
```

## Use Collections






